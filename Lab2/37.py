# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Jseo2q5d12-cjI8tiZXk4Ae3FKEYYA27
"""

import matplotlib.pyplot as plt

def f(x):
    return x**3 - x - 1

def secant_method(x0, x1, tol=1e-6, max_iter=50):
    approx_errors = []
    relative_approx_errors = []
    iterations = 0

    while iterations < max_iter:
        fx0 = f(x0)
        fx1 = f(x1)
        x_next = x1 - fx1 * (x1 - x0) / (fx1 - fx0)

        approx_error = abs(x_next - x1)
        relative_approx_error = abs(approx_error / x_next)

        approx_errors.append(approx_error)
        relative_approx_errors.append(relative_approx_error)

        x0 = x1
        x1 = x_next

        iterations += 1

        if approx_error < tol:
            break

    return x_next, approx_errors, relative_approx_errors

# Initial guesses
x0 = 50
x1 = 48

# Run the Secant Method
solution, approx_errors, relative_approx_errors = secant_method(x0, x1)

# Print the solution
print("Solution using Secant Method:", solution)

# Plot the approximation errors and relative approximation errors
iterations = range(1, len(approx_errors) + 1)

plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.bar(iterations, approx_errors)
plt.xlabel('Iteration Number')
plt.ylabel('Approximation Error')
plt.title('Approximation Error vs Iteration Number')

plt.subplot(1, 2, 2)
plt.bar(iterations, relative_approx_errors)
plt.xlabel('Iteration Number')
plt.ylabel('Relative Approximation Error')
plt.title('Relative Approximation Error vs Iteration Number')

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

def f(x):
    return x**3 - x - 1

def f_prime(x):
    return 3*x**2 - 1

def newton_raphson_method(x0, tol=1e-6, max_iter=50):
    approx_errors = []
    relative_approx_errors = []
    iterations = 0

    while iterations < max_iter:
        fx = f(x0)
        f_prime_x = f_prime(x0)

        if f_prime_x == 0:
            break

        x_next = x0 - fx / f_prime_x

        approx_error = abs(x_next - x0)
        relative_approx_error = abs(approx_error / x_next)

        approx_errors.append(approx_error)
        relative_approx_errors.append(relative_approx_error)

        x0 = x_next

        iterations += 1

        if approx_error < tol:
            break

    return x_next, approx_errors, relative_approx_errors

# Initial guess for Newton-Raphson
x0_newton = 50

# Run the Newton-Raphson Method
solution_newton, approx_errors_newton, relative_approx_errors_newton = newton_raphson_method(x0_newton)

# Initial guesses for Secant Method
x0_secant = 50
x1_secant = 48

# Run the Secant Method
solution_secant, approx_errors_secant, relative_approx_errors_secant = secant_method(x0_secant, x1_secant)

# Print the solutions
print("Solution using Newton-Raphson Method:", solution_newton)
print("Solution using Secant Method:", solution_secant)

# Create line chart for Approximation Errors comparison
iterations_newton = range(1, len(approx_errors_newton) + 1)
iterations_secant = range(1, len(approx_errors_secant) + 1)

plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.plot(iterations_newton, approx_errors_newton, label='Newton-Raphson')
plt.plot(iterations_secant, approx_errors_secant, label='Secant')
plt.xlabel('Iteration Number')
plt.ylabel('Approximation Error')
plt.title('Approximation Error Comparison')
plt.legend()

# Create line chart for Relative Approximation Errors comparison
plt.subplot(1, 2, 2)
plt.plot(iterations_newton, relative_approx_errors_newton, label='Newton-Raphson')
plt.plot(iterations_secant, relative_approx_errors_secant, label='Secant')
plt.xlabel('Iteration Number')
plt.ylabel('Relative Approximation Error')
plt.title('Relative Approximation Error Comparison')
plt.legend()

plt.tight_layout()
plt.show()